"""
MateBot command executor classes for /consume
"""

import random

import telegram
from matebot_sdk import schemas
from matebot_sdk.base import PermissionLevel

from .. import util
from ..base import BaseCommand
from ..client import SDK
from ..parsing.types import natural as natural_type, extended_consumable_type
from ..parsing.util import Namespace


class ConsumeCommand(BaseCommand):
    """
    Command executor for /consume
    """

    def __init__(self):
        super().__init__(
            "consume",
            "Use this command to consume consumable goods.\n\n"
            "The first argument `consumable` determines which good you want to consume, "
            "while the optional second argument `number` determines the number of "
            "consumed goods (defaulting to a single one). Use the special consumable "
            "`?` to get a list of all available consumable goods currently available."
        )

        self.parser.add_argument("consumable", type=extended_consumable_type)
        self.parser.add_argument("number", default=1, type=natural_type, nargs="?")

    async def run(self, args: Namespace, update: telegram.Update) -> None:
        """
        :param args: parsed namespace containing the arguments
        :type args: argparse.Namespace
        :param update: incoming Telegram update
        :type update: telegram.Update
        :return: None
        """

        sender = await SDK.get_user_by_app_alias(str(update.effective_message.from_user.id))
        permission_check = SDK.ensure_permissions(sender, PermissionLevel.ANY_WITH_VOUCHER, "consume")
        if not permission_check[0]:
            update.effective_message.reply_text(permission_check[1])
            return

        consumable = args.consumable

        if isinstance(consumable, str) and consumable == "?":
            msg = await self.get_consumable_help()
            util.safe_call(
                lambda: update.effective_message.reply_markdown(msg),
                lambda: update.effective_message.reply_text(msg)
            )

        elif isinstance(consumable, schemas.Consumable):
            await SDK.consume(consumable, args.number, sender)
            msg = random.choice(consumable.messages) + consumable.symbol * args.number
            util.safe_call(
                lambda: update.effective_message.reply_markdown(msg),
                lambda: update.effective_message.reply_text(msg)
            )

        else:
            raise RuntimeError(f"Invalid consumable: {consumable!r} {type(consumable)}")

    @staticmethod
    async def get_consumable_help() -> str:
        # TODO: improve the line of text generated by this function
        def make_line(c: schemas.Consumable) -> str:
            return f"{c.symbol} {c.name} (price {c.price/100:.2f}â‚¬): {c.description} (stock: {c.stock})"

        lines = "\n".join([make_line(c) for c in await SDK.get_consumables()])
        return f"The following consumables are currently available:\n\n{lines}"
